# goal: (clean_{d+s}(data+sim) - clean_d(data)) x delta / meansub_sim x delta
pipe_modules = []
pipe_processes = 1

from map import map_operations
from map import simulate_gbt_signal
from quadratic_products import pwrspec_combinations
from foreground_clean import pair_set_extended
import struct
import os

# flags for scinet vs. tpb
basedir = "/mnt/raid-project/gmrt/eswitzer/GBT/"
#basedir = "/scratch/r/rbond/eswitzer/GBT/"

#-----------------------------------------------------------------------------
# main parameters that define the run
#-----------------------------------------------------------------------------
instance_seed = struct.unpack("I", os.urandom(4))[0]
print "generating simulation with seed: %d" % instance_seed

basemap = "GBT_15hr_map_oldcalpol"
baseauto = basemap + "_x_" + basemap
#output_tag = baseauto + "_" + "blackman_order1"
output_tag = baseauto + "_" + "order1"

do_simulation = True
do_physpower = True
do_ext_cleaning = True
# this only needs to be done once
do_clean_orig = True
do_modepower = True
do_cleanup = True

# simulation options
sim_refinement = 2.
sim_scenario = "str"
sim_multiplier = 1.

# cleaning options
nfreq = 256
cutlist = [6, 7, 8, 15, 16, 18, 19, 20, 21, 22, 37, 80, 103, 104, 105, 106, \
               107, 108, 130, 131, 132, 133, 134, 171, 175, 177, 179, 182, 183, \
               187, 189, 192, 193, 194, 195, 196, 197, 198, 201, 204, 208, 209, \
               212, 213, 218, 219, 229, 233, 237, 244, 254, 255]
freq_list = tuple([ind for ind in range(nfreq) if ind not in cutlist])
clean_mode_list = range(0, 105, 5)
clean_common_res_convolution = False
clean_sub_weighted_mean = True
clean_factorizable = True
clean_sim_multiplier = 1.
clean_weighted_svd = False

# power spectrum settings
pwr_bins = [0.003, 2.5, 45]
pwr_order = 1
pwr_pad = 5
pwr_refinement = 2
#pwr_window = "blackman"
pwr_window = None
pwr_return_3d = False
pwr_unitless = True
pwr_truncate = False
pwr_degrade_resolution = False
pwr_factorizable_noise = False
pwr_meansub = False
pwrout_root = basedir + 'pwrspec/'
pwrout_base = pwrout_root + output_tag

#-----------------------------------------------------------------------------
# generate the signal sims and find the power spectrum
#-----------------------------------------------------------------------------
if not os.path.isdir(pwrout_base + "_onesided_sims/"):
    os.mkdir(pwrout_base + "_onesided_sims/")

# TODO replace with SimulateGbt
if do_simulation:
    pipe_modules.append((simulate_gbt_signal.SimulateGbtSignal, ('sg1_', 'sg_')))
sg1_output_root = pwrout_base + "_onesided_sims/"
sg1_template_file = "db:" + basemap + ":A;noise_weight"
sg1_seed = instance_seed
sg1_refinement = 2
sg1_weightfile = "db:" + basemap + ":A;noise_weight"
sg1_outfile_meansub = "%s_sim_beammeansub_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_raw = "%s_sim_raw_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_delta = "%s_sim_delta_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_physical = "%s_sim_phys_%d.npy" % (output_tag, sg1_seed)

if not os.path.isdir(pwrout_base + "_onesided_phys/"):
    os.mkdir(pwrout_base + "_onesided_phys/")

if do_physpower:
    pipe_modules.append((pwrspec_combinations.SinglePhysicalSim, ('sps1_', 'sps_')))
sps1_sim_file_left = sg1_output_root + sg1_outfile_physical
sps1_sim_file_right = sg1_output_root + sg1_outfile_physical
sps1_unitless = pwr_unitless
sps1_return_3d = pwr_return_3d
sps1_truncate = pwr_truncate
sps1_window = pwr_window
sps1_bins = pwr_bins
sps1_ncpu = 1
sps1_outfile = "%s_phys/%s_physsim_%d.shelve" % (pwrout_base, output_tag, instance_seed)

#-----------------------------------------------------------------------------
# clean_{map+sim} (map+sim) - clean_{map}(map)
#-----------------------------------------------------------------------------
if do_ext_cleaning:
    pipe_modules.append((pair_set_extended.PairSetExtended, ('fse1_', 'fse_')))
fse1_map2 = basemap
fse1_map1 = basemap
fse1_noise_inv1 = basemap
fse1_noise_inv2 = basemap
fse1_map2_ext = [basemap + "_Q", basemap + "_U"]
fse1_map1_ext = [basemap + "_Q", basemap + "_U"]
fse1_noise_inv1_ext = [basemap + "_Q", basemap + "_U"]
fse1_noise_inv2_ext = [basemap + "_Q", basemap + "_U"]
fse1_index_ext = ["stokesQ", "stokesU"]
fse1_output_root = basemap + "_cleaned_plussim_path_Eric"
fse1_freq_list = freq_list
fse1_modes = clean_mode_list
fse1_factorizable_noise = True
fse1_convolve = clean_common_res_convolution
fse1_weighted_SVD = clean_weighted_svd
fse1_sub_weighted_mean = clean_sub_weighted_mean
fse1_simfile = sg1_output_root + sg1_outfile_meansub
fse1_sim_multiplier = clean_sim_multiplier
fse1_subtract_inputmap_from_sim = False
fse1_subtract_sim_from_inputmap = False
fse1_tack_on_output = "%d_simulation" % instance_seed

if do_clean_orig:
    pipe_modules.append((pair_set_extended.PairSetExtended, ('fse2_', 'fse_')))
fse2_map2 = basemap
fse2_map1 = basemap
fse2_noise_inv1 = basemap
fse2_noise_inv2 = basemap
fse2_map2_ext = [basemap + "_Q", basemap + "_U"]
fse2_map1_ext = [basemap + "_Q", basemap + "_U"]
fse2_noise_inv1_ext = [basemap + "_Q", basemap + "_U"]
fse2_noise_inv2_ext = [basemap + "_Q", basemap + "_U"]
fse2_index_ext = ["stokesQ", "stokesU"]
fse2_output_root = basemap + "_cleaned_path_Eric"
fse2_freq_list = freq_list
fse2_modes = clean_mode_list
fse2_factorizable_noise = True
fse2_convolve = clean_common_res_convolution
fse1_weighted_SVD = clean_weighted_svd
fse2_sub_weighted_mean = clean_sub_weighted_mean

# now find cleaned_simulation = clean_{d+s}(data+sim) - clean_d(data)
pipe_modules.append((map_operations.SubtractMaps, ('sm1_', 'sm_')))
sm_map_key_1 = basemap + "_cleaned_plussim_combined"
sm_tack_on_1 = "%d_simulation" % instance_seed
sm_map_key_2 = basemap + "_cleaned_combined"
sm_tack_on_2 = None
sm_map_key_out = basemap + "_cleaned_plussim_combined"
sm_tack_on_out = "%d_simminusmap" % instance_seed

#-----------------------------------------------------------------------------
# find sim x sim and cleaned sim x sim
#-----------------------------------------------------------------------------
if not os.path.isdir(pwrout_base + "_onesided_obsbeammeansub"):
    os.mkdir(pwrout_base + "_onesided_obsbeammeansub")

# find the denominator of the mode loss trans: map weight * sim x delta
if do_modepower:
    pipe_modules.append((pwrspec_combinations.BatchSimCrosspower, ('bxs1_', 'bxs_')))
bxs1_degrade_resolution = pwr_degrade_resolution
bxs1_factorizable_noise = pwr_factorizable_noise
bxs1_meansub = pwr_meansub
bxs1_unitless = pwr_unitless
bxs1_return_3d = pwr_return_3d
bxs1_truncate = pwr_truncate
bxs1_window = pwr_window
bxs1_refinement = pwr_refinement
bxs1_pad = pwr_pad
bxs1_order = pwr_order
bxs1_bins = pwr_bins
bxs1_freq_list = freq_list
bxs1_map_key = basemap + "_cleaned_combined"
#bxs1_tack_on = "%d_simminusmap" % instance_seed
bxs1_sim_file = sg1_output_root + sg1_outfile_meansub
bxs1_wigglez_sim_file = sg1_output_root + sg1_outfile_delta
bxs1_wigglez_sel_key = None
bxs1_outfile = "%s_onesided_obsbeammeansub/%s_sim_%d.shelve" % (pwrout_base, output_tag, instance_seed)

if not os.path.isdir(pwrout_base + "_onesided_modeclean_plussim"):
    os.mkdir(pwrout_base + "_onesided_modeclean_plussim")

# find the denominator of the mode loss trans: map weight * cleaned_simulation x delta
if do_modepower:
    pipe_modules.append((pwrspec_combinations.WiggleZxGBT_modesim, ('wxss1_', 'wxss_')))
wxss1_degrade_resolution = pwr_degrade_resolution
wxss1_factorizable_noise = pwr_factorizable_noise
wxss1_meansub = pwr_meansub
wxss1_unitless = pwr_unitless
wxss1_return_3d = pwr_return_3d
wxss1_truncate = pwr_truncate
wxss1_window = pwr_window
wxss1_refinement = pwr_refinement
wxss1_pad = pwr_pad
wxss1_order = pwr_order
wxss1_bins = pwr_bins
wxss1_freq_list = freq_list
wxss1_ncpu = 1
wxss1_map_key = basemap + "_cleaned_plussim_combined"
wxss1_tack_on = "%d_simminusmap" % instance_seed
wxss1_wigglez_sim_file = sg1_output_root + sg1_outfile_delta
wxss1_wigglez_sel_key = None
wxss1_outfile_data = "%s_onesided_modeclean_plussim/%s_sim_%d.shelve" % (pwrout_base, output_tag, instance_seed)

#-----------------------------------------------------------------------------
# now remove the intermediate cleaned files
#-----------------------------------------------------------------------------
if do_cleanup:
    pipe_modules.append((pwrspec_combinations.CleanupCleanedMaps, ('clean1_', 'clean_')))
clean1_path_key = basemap + "_cleaned_plussim_path_Eric"
clean1_tack_on = "%d_simulation" % instance_seed

if do_cleanup:
    pipe_modules.append((pwrspec_combinations.CleanupCleanedMaps, ('clean2_', 'clean_')))
clean2_path_key = basemap + "_cleaned_plussim_path_Eric"
clean2_tack_on = "%d_simminusmap" % instance_seed
