pipe_modules = []
pipe_processes = 1

from map import simulate_gbt
from quadratic_products import pwrspec_combinations
import struct
import os

randsource = open("/dev/random", "rb")
instance_seed = struct.unpack("I", randsource.read(4))[0]
print "generating simulation with seed: %d" % instance_seed

# main control flags
basemap = "GBT_15hr_map_oldcal"
baseoptmap = "WiggleZ_15hr"
# this is just used to get the map geometry
map_template = "/mnt/raid-project/gmrt/eswitzer/GBT/maps/15hr_oldcal/sec_A_15hr_41-90_clean_map_I.npy"
basecross = basemap + "_x_" + baseoptmap
output_tag = basecross + "_" + "blackman_order1"

nfreq = 256
cutlist = [6, 7, 8, 15, 16, 18, 19, 20, 21, 22, 37, 80, 103, 104, 105, 106, \
               107, 108, 130, 131, 132, 133, 134, 171, 175, 177, 179, 182, 183, \
               187, 189, 192, 193, 194, 195, 196, 197, 198, 201, 204, 208, 209, \
               212, 213, 218, 219, 229, 233, 237, 244, 254, 255]
freq_list = tuple([ind for ind in range(nfreq) if ind not in cutlist])

pwr_bins = [0.00765314, 2.49977141, 35]
pwr_order = 1
pwr_pad = 5
pwr_refinement = 2
pwr_window = "blackman"
#pwr_window = None
pwr_return_3d = False
pwr_unitless = True
pwr_truncate = False
pwr_degrade_resolution = False
pwr_factorizable_noise = False
pwr_meansub = False
pwrout_root = '/mnt/raid-project/gmrt/eswitzer/GBT/bulksim/'
pwrout_base = pwrout_root + output_tag

# TODO: where is meansub in this?
# TODO: identify the sim file input to the power
# TODO: simulations of the physical/temperature overdensity field

if not os.path.isdir(pwrout_base):
    os.mkdir(pwrout_base)

pipe_modules.append((simulate_gbt.SimulateGbt, ('sg1_', 'sg_')))
sg1_output_root = pwrout_base + "_sims/"
sg1_template_file = map_template
sg1_seed = instance_seed
sg1_refinement = 2
sg1_outfile_beam = "%s_sim_beam_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_raw = "%s_sim_raw_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_physical = "%s_sim_phys_%d.npy" % (output_tag, sg1_seed)
sg1_outfile_beam_plus_data = None
#sg1_outfile_beam_plus_data = "%s_sim_beamplusdata_%d.npy" % (output_tag, sg1_seed)

# first find the crosspower in the observed region with beam and meansub
pipe_modules.append((pwrspec_combinations.BatchSimCrosspower, ('bxs1_', 'bxs_')))
bxs1_map_key = basemap + "_combined_cleaned"
bxs1_sim_file = sg1_outfile_beam
bxs1_wigglez_sim_file = sg1_outfile_raw
bxs1_wigglez_sel_key = baseoptmap + "_montecarlo"
bxs1_outfile = "%s_obsbeammeansub/%s_sim_%d.shelve" % (pwrout_base, output_tag, sg1_seed)
bxs1_unitless = pwr_unitless
bxs1_return_3d = pwr_return_3d
bxs1_truncate = pwr_truncate
bxs1_window = pwr_window
bxs1_degrade_resolution = pwr_degrade_resolution
bxs1_factorizable_noise = pwr_factorizable_noise
bxs1_meansub = pwr_meansub
bxs1_refinement = pwr_refinement
bxs1_pad = pwr_pad
bxs1_order = pwr_order
bxs1_freq_list = freq_list
bxs1_bins = pwr_bins

# now the crosspower in the observed region (no beam or meansub)
pipe_modules.append((pwrspec_combinations.BatchSimCrosspower, ('bxs2_', 'bxs_')))
bxs2_map_key = basemap + "_combined_cleaned"
bxs2_sim_file = sg1_outfile_raw
bxs2_wigglez_sim_file = sg1_outfile_raw
bxs2_wigglez_sel_key = baseoptmap + "_montecarlo"
bxs2_outfile = "%s_obs/%s_sim_%d.shelve" % (pwrout_base, output_tag, sg1_seed)
bxs2_unitless = pwr_unitless
bxs2_return_3d = pwr_return_3d
bxs2_truncate = pwr_truncate
bxs2_window = pwr_window
bxs2_degrade_resolution = pwr_degrade_resolution
bxs2_factorizable_noise = pwr_factorizable_noise
bxs2_meansub = pwr_meansub
bxs2_refinement = pwr_refinement
bxs2_pad = pwr_pad
bxs2_order = pwr_order
bxs2_freq_list = freq_list
bxs2_bins = pwr_bins

# now the crosspower in the physical region (to measure pixel window function)
pipe_modules.append((pwrspec_combinations.SinglePhysicalSim, ('sps1_', 'sps_')))
sps1_sim_file_left = simfile
sps1_sim_file_right = simfile
sps1_unitless = pwr_unitless
sps1_return_3d = pwr_return_3d
sps1_truncate = pwr_truncate
sps1_window = pwr_window
sps1_bins = pwr_bins
sps1_outfile = "%s_phys/%s_physsim_%d.shelve" % (pwrout_base, output_tag, sg1_seed)
